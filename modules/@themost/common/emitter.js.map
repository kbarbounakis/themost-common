{"version":3,"sources":["emitter.js"],"names":["applyEachSeries","EventEmitter","Symbol","listenersProperty","listenerProperty","SequentialEventEmitter","event","args","Error","argsAndCallback","concat","Array","prototype","slice","call","arguments","length","TypeError","callback","listeners","apply","listener","n","type","self","fired","g","removeListener","on"],"mappings":";;;;;;;;;;;AAQA;;IAAQA,e,UAAAA,e;;AACR;;IAAQC,Y,WAAAA,Y;;AACR;;IAAOC,O;;;;;;;;+eAVP;;;;;;;;;;AAWA,IAAMC,oBAAoB,WAA1B;AACA,IAAMC,mBAAmBF,QAAO,UAAP,CAAzB;AACA;;;;;IAIaG,sB,WAAAA,sB;;;AAET;;;AAGA,sCAAc;AAAA;;AAAA;AAEb;;AAED;;;;;;AAMJ;;;;;6BACSC,K,EAAgB;AAAA,8CAANC,IAAM;AAANA,oBAAM;AAAA;;AACjB;AACA,gBAAI,OAAO,KAAKJ,iBAAL,CAAP,KAAmC,UAAvC,EAAmD;AAC/C,sBAAM,IAAIK,KAAJ,CAAU,qBAAV,CAAN;AACH;AACD;AACA,gBAAMC,kBAAkB,GAAGC,MAAH,CAAUC,MAAMC,SAAN,CAAgBC,KAAhB,CAAsBC,IAAtB,CAA2BC,SAA3B,EAAsC,CAAtC,CAAV,CAAxB;AACA,gBAAIN,gBAAgBO,MAAhB,GAAyB,CAA7B,EAAgC;AAC5B;AACA,oBAAI,OAAOP,gBAAgBA,gBAAgBO,MAAhB,GAAyB,CAAzC,CAAP,KAAuD,UAA3D,EAAuE;AACnE,0BAAM,IAAIC,SAAJ,CAAc,yBAAd,CAAN;AACH;AACJ;AACD;AACA,gBAAMC,WAAWT,gBAAgBA,gBAAgBO,MAAhB,GAAyB,CAAzC,CAAjB;AACA;AACA,gBAAMG,YAAY,KAAKhB,iBAAL,EAAwBG,KAAxB,CAAlB;AACA;AACA,gBAAIa,UAAUH,MAAV,KAAqB,CAAzB,EAA4B;AACxB;AACA,uBAAOE,UAAP;AACH;AACD;AACA,mBAAOlB,gBAAgBoB,KAAhB,CAAsB,IAAtB,EAA4B,CAACD,SAAD,EAAYT,MAAZ,CAAmBD,eAAnB,CAA5B,CAAP;AACH;;AAED;;;;;;;;oCAKYH,K,EAAOe,Q,EAAU;AACzB,+JAAyBf,KAAzB,EAAgCe,QAAhC;AACH;AACD;;;;;;;;2BAKGf,K,EAAOe,Q,EAAU;AAChB,sJAAgBf,KAAhB,EAAuBe,QAAvB;AACH;AACD;;;;;;;;wCAKgBf,K,EAAOe,Q,EAAU;AAC7B,mKAA6Bf,KAA7B,EAAoCe,QAApC;AACH;AACD;;;;;;;;4CAKoBf,K,EAAOe,Q,EAAU;AACjC,uKAAiCf,KAAjC,EAAwCe,QAAxC;AACH;AACD;;;;;;;;uCAKef,K,EAAOe,Q,EAAU;AAC5B,kKAA4Bf,KAA5B,EAAmCe,QAAnC;AACH;AACD;;;;;;;2CAImBf,K,EAAO;AAC1B,sKAAgCA,KAAhC;AACH;;AAEG;;;;;;;wCAIgBgB,C,EAAG;AACnB,mKAA6BA,CAA7B;AACH;;AAEG;;;;;;0CAGkB;AAClB;AACH;;AAEG;;;;;;;sCAIcC,I,EAAM;AACpB,iKAA2BA,IAA3B;AACH;;AAEG;;;;;;;;6BAKKjB,K,EAAOe,Q,EAAU;AACtB,gBAAMG,OAAO,IAAb;AACA,gBAAI,OAAOH,QAAP,KAAoB,UAAxB,EAAoC;AAChC,sBAAMJ,UAAU,6BAAV,CAAN;AACH;AACD,gBAAIQ,QAAQ,KAAZ;AACA,qBAASC,CAAT,GAAa;AACTF,qBAAKG,cAAL,CAAoBrB,KAApB,EAA2BoB,CAA3B;AACA,oBAAI,CAACD,KAAL,EAAY;AACRA,4BAAQ,IAAR;AACAJ,6BAASD,KAAT,CAAe,IAAf,EAAqBL,SAArB;AACH;AACJ;AACDW,cAAEtB,gBAAF,IAAsBiB,QAAtB;AACAG,iBAAKI,EAAL,CAAQtB,KAAR,EAAeoB,CAAf;AACA,mBAAO,IAAP;AACH;;;;EAtI2CzB,Y","file":"emitter.js","sourcesContent":["/**\n * @license\n * MOST Web Framework 2.0 Codename Blueshift\n * Copyright (c) 2017, THEMOST LP All rights reserved\n *\n * Use of this source code is governed by an BSD-3-Clause license that can be\n * found in the LICENSE file at https://themost.io/license\n */\nimport {applyEachSeries} from \"async\";\nimport {EventEmitter} from \"events\";\nimport Symbol from \"symbol\";\nconst listenersProperty = \"listeners\";\nconst listenerProperty = Symbol(\"listener\");\n/**\n * @class\n * @extends EventEmitter\n */\nexport class SequentialEventEmitter extends EventEmitter {\n\n    /**\n     * @constructor\n     */\n    constructor() {\n        super();\n    }\n\n    /**\n     * Emits an event by specifying additional arguments where the last argument is a callback function\n     * @param {string | symbol} event\n     * @param args\n     * @returns {*}\n     */\n// eslint-disable-next-line no-unused-vars\n    emit(event, ...args) {\n        //get listeners\n        if (typeof this[listenersProperty] !== \"function\") {\n            throw new Error(\"undefined listeners\");\n        }\n        //get arguments as array (remove the first argument -event name-)\n        const argsAndCallback = [].concat(Array.prototype.slice.call(arguments, 1));\n        if (argsAndCallback.length > 0) {\n            //check the last argument (expected callback function)\n            if (typeof argsAndCallback[argsAndCallback.length - 1] !== \"function\") {\n                throw new TypeError(\"Expected event callback\");\n            }\n        }\n        //get callback function (the last argument of arguments list)\n        const callback = argsAndCallback[argsAndCallback.length - 1];\n        //get array of listeners\n        const listeners = this[listenersProperty](event);\n        //validate listeners\n        if (listeners.length === 0) {\n            //exit emitter by executing the defined callback\n            return callback();\n        }\n        //apply each series\n        return applyEachSeries.apply(this, [listeners].concat(argsAndCallback));\n    }\n\n    /**\n     * @param {string|symbol} event\n     * @param {Function} listener\n     * @returns this\n     */\n    addListener(event, listener) {\n        return super.addListener(event, listener);\n    }\n    /**\n     * @param {string|symbol} event\n     * @param {Function} listener\n     * @returns this\n     */\n    on(event, listener) {\n        return super.on(event, listener);\n    }\n    /**\n     * @param {string|symbol} event\n     * @param {Function} listener\n     * @returns this\n     */\n    prependListener(event, listener) {\n        return super.prependListener(event, listener);\n    }\n    /**\n     * @param {string|symbol} event\n     * @param {Function} listener\n     * @returns this\n     */\n    prependOnceListener(event, listener) {\n        return super.prependOnceListener(event, listener);\n    }\n    /**\n     * @param {string|symbol} event\n     * @param {Function} listener\n     * @returns this\n     */\n    removeListener(event, listener) {\n        return super.removeListener(event, listener);\n    }\n    /**\n     * @param {string|symbol} event\n     * @returns this\n     */\n    removeAllListeners(event) {\n    return super.removeAllListeners(event);\n}\n\n    /**\n     * @param {number} n\n     * @returns this\n     */\n    setMaxListeners(n) {\n    return super.setMaxListeners(n);\n}\n\n    /**\n     * @return {*|number}\n     */\n    getMaxListeners() {\n    return super.getMaxListeners();\n}\n\n    /**\n     * @param type\n     * @return {*|number}\n     */\n    listenerCount(type) {\n    return super.listenerCount(type);\n}\n\n    /**\n     * @param {string|symbol} event\n     * @param {Function} listener\n     * @return {SequentialEventEmitter}\n     */\n    once(event, listener) {\n    const self = this;\n    if (typeof listener !== \"function\") {\n        throw TypeError(\"listener must be a function\");\n    }\n    let fired = false;\n    function g() {\n        self.removeListener(event, g);\n        if (!fired) {\n            fired = true;\n            listener.apply(this, arguments);\n        }\n    }\n    g[listenerProperty] = listener;\n    self.on(event, g);\n    return this;\n}\n}\n"]}